#!/usr/bin/env bash
#
# Get and set configuration values in a consistent style.
# 
# Example usage:
# ```bash
# flow-config myCoolProject notifications.enabled
# flow-config myCoolProject --set notifications.enabled false
# ```

# yell() { echo "$0: $*" >&2; }
# die() { yell "$*"; exit 111; }
# try() { "$@" || die "cannot $*"; }

set -o errexit   # abort on nonzero exitstatus
set -o nounset   # abort on unbound variable
set -o pipefail  # don't hide errors within pipes 

VERSION="v0.0.1"

main()
{
  if [[ "$_arg_set" == "on" ]]; then
    echo "set is not implemented yet"
  else
    set -x
    get_value
    set +x
  fi
}


search_path() {
  echo ".$_arg_key"
}


get_value() {
  require_config_exists=failfast

  if [[ "$_arg_value" != "" ]]; then
    require_config_exists=nofail
  fi

  config_file=$(config_file_fullpath "$require_config_exists")
  search_path=$(search_path "$_arg_key")

  jq "$search_path" "$config_file"
}


# output_or_fail() {
# 
# }


config_file_fullpath() {
  fail_if_not_exists="yes"

  if [[ "$1" == "nofail" ]]; then
    fail_if_not_exists="no"
    shift
  fi

  config_file="$HOME/.config/$_arg_config/config.json"

  if [[ "$fail_if_not_exists" != "no" ]]; then
    test -e "$config_file" || die "Configuration does not yet exist for that namespace"
  fi

  echo "$config_file"
  return 0
}


# ARG_OPTIONAL_BOOLEAN([set],[s],[Set value for config])
# ARG_POSITIONAL_SINGLE([config],[Configuration namespace to perform lookup],[])
# ARG_POSITIONAL_SINGLE([key],[Specific key to get or set],[])
# ARG_POSITIONAL_SINGLE([value],[Value to set],[''])
# ARG_HELP([Config tool to power other bash scripts])
# ARG_VERSION_AUTO([$VERSION])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='shv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}


# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_config=""
_arg_key=""
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_set="off"
_arg_value=""


print_help()
{
	printf '%s\n' "Config tool to power other bash scripts"
	printf 'Usage: %s [-s|--(no-)set] [-h|--help] [-v|--version] <config> <key> [<value>]\n' "$0"
	printf '\t%s\n' "<config>: Configuration namespace to perform lookup"
	printf '\t%s\n' "<key>: Specific key to get or set"
	printf '\t%s\n' "<value>:"
	printf '\t%s\n' "  on get:  default value"
	printf '\t%s\n' "  on set:  value to set"
	printf '\t%s\n' "-s, --set, --no-set: Set value for config (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-v, --version: Prints version"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-s|--no-set|--set)
				_arg_set="on"
				test "${1:0:5}" = "--no-" && _arg_set="off"
				;;
			-s*)
				_arg_set="on"
				_next="${_key##-s}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-s" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--version)
				printf '%s %s\n\n%s\n' "" "$VERSION" 'Config tool to power other bash scripts'
				exit 0
				;;
			-v*)
				printf '%s %s\n\n%s\n' "" "$VERSION" 'Config tool to power other bash scripts'
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'config' and 'key'"
	test "${_positionals_count}" -ge 2 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require between 2 and 3 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 3 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 2 and 3 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_config _arg_key _arg_value "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}


parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

[[ "$0" == "${BASH_SOURCE[0]}" ]] && main

# ] <-- needed because of Argbash
